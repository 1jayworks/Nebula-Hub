local NewNebulaHub = game:GetObjects("rbxassetid://120598545722098")[1].NebulaHub;
NewNebulaHub.Parent = game:GetService("CoreGui");

local Dependencies = NewNebulaHub.Dependencies;

local RunService = game:GetService("RunService");
local TweenService = game:GetService("TweenService");
local Players = game:GetService("Players");

local Connection = {};
Connection.__index = Connection;

function Connection.new(callback : (...any) -> ...any)
	return setmetatable({
		Connected = true;
		Callback = callback;
	}, Connection);
end

function Connection:Disconnect()
	self.Connected = false;
end

table.freeze(Connection);

export type Connection = typeof(Connection.new(function() end));

export type SignalPrototype<T...> = {
	__index : SignalPrototype<T...>;
	Fire : (self : Signal<T...>, T...) -> ();
	Wait : (self : Signal<T...>) -> T...;
	Once : (self : Signal<T...>, func: (T...) -> ()) -> Connection;
	Connect : (self : Signal<T...>, func: (T...) -> ()) -> Connection;
	ConnectParallel : (self : Signal<T...>, func: (T...) -> ()) -> Connection;
}

export type Signal<T... = ()> = typeof(
	setmetatable(
		{destroyed=(nil::any)::boolean; connections={}::{Connection}; parallel_connections={}::{Connection}},
		{}::SignalPrototype<T...>
	)
);

local Signal = {};
Signal.__index = Signal;

function Signal.new<T...>() : Signal<T...>
	return setmetatable({
		destroyed = false;
		connections = {}::{Connection};
		parallel_connections = {}::{Connection};
	}, Signal);
end

function Signal:Connect<T...>(func: (T...) -> ())
	if (self.destroyed) then
		error("[Signal] Cannot connect signal while destroyed", 2);
	end
	local connection = Connection.new(func);

	table.insert(self.connections, connection);

	return connection;
end

function Signal:ConnectParallel<T...>(func: (T...) -> ())
	if (self.destroyed) then
		error("[Signal] Cannot connect signal while destroyed", 2);
	end
	local connection = Connection.new(func);

	table.insert(self.parallel_connections, connection);

	return connection;
end

function Signal:Fire<T...>(...) : ()
	if (self.destroyed) then
		error("[Signal] Cannot call signal while destroyed", 2);
	end
	for _, connection in self.parallel_connections do
		if (connection.Connected) then
			task.spawn(function(...)
				task.desynchronize();
				connection.Callback(...);
			end, ...)
		end
	end
	for _, connection in self.connections do
		if (connection.Connected) then
			task.spawn(connection.Callback, ...);
		end
	end

	for i = #self.connections, 1, -1 do
		local connection = self.connections[i];
		if (not connection.Connected) then
			table.remove(self.connections, i);
		end
	end

	for i = #self.parallel_connections, 1, -1 do
		local connection = self.parallel_connections[i];
		if (not connection.Connected) then
			table.remove(self.parallel_connections, i);
		end
	end
end

function Signal:Wait<T...>() : T...
	local thread = coroutine.running();
	self:Once(function(...)
		coroutine.resume(thread, ...);
	end)
	return coroutine.yield();
end

function Signal:Once<T...>(func: (T...) -> ()) : Connection
	local connection;
	connection = self:Connect(function(... : T...)
		if (connection and connection.Connected) then
			connection:Disconnect();
		end
		func(...);
	end)
	return connection;
end

function Signal:Clone<T...>() : Signal<T...>
	if (self.destroyed) then
		error("[Signal] Cannot clone signal while destroyed", 2);
	end
	return Signal.new();
end

function Signal:Destroy()
	self.destroyed = true;
	table.clear(self.parallel_connections);
	table.clear(self.connections);
end

local Slider = {Sliders = {}}

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local SliderFuncs = {}

function SliderFuncs.snapToScale(val: number, step: number): number
	return math.clamp(math.round(val / step) * step, 0, 1)
end

function lerp(start: number, finish: number, percent: number): number
	return (1 - percent) * start + percent * finish
end

function SliderFuncs.map(value: number, start: number, stop: number, newStart: number, newEnd: number, constrain: boolean): number
	local newVal = lerp(newStart, newEnd, SliderFuncs.getAlphaBetween(start, stop, value))
	if not constrain then
		return newVal
	end

	if newStart < newEnd then
		newStart, newEnd = newEnd, newStart
	end

	return math.max(math.min(newVal, newStart), newEnd)
end

function SliderFuncs.getNewPosition(self): UDim2
	local absoluteSize = self._data.Button.AbsoluteSize[self._config.Axis]
	local holderSize = self._holder.AbsoluteSize[self._config.Axis]

	local anchorPoint = self._data.Button.AnchorPoint[self._config.Axis]

	local paddingScale = (self._config.Padding / holderSize)

	local minScale = ((anchorPoint * absoluteSize) / holderSize + paddingScale)
	local decrement = ((2 * absoluteSize) * anchorPoint) - absoluteSize
	local maxScale = (1 - minScale) + (decrement / holderSize)

	local newPercent = SliderFuncs.map(self._data._percent, 0, 1, minScale, maxScale, true)

	return 
		if self._config.Axis == "X" then UDim2.fromScale(newPercent, self._data.Button.Position.Y.Scale)
		else UDim2.fromScale(self._data.Button.Position.X.Scale, newPercent)
end

function SliderFuncs.getScaleIncrement(self)
	return 1 / ((self._config.SliderData.End - self._config.SliderData.Start) / self._config.SliderData.Increment)
end

function SliderFuncs.getAlphaBetween(a: number, b: number, c: number): number
	return (c - a) / (b - a)
end

function SliderFuncs.getNewValue(self)
	local newValue = lerp(self._config.SliderData.Start, self._config.SliderData.End, self._data._percent)
	local incrementScale = (1 / self._config.SliderData.Increment)

	newValue = math.round(newValue * incrementScale) / incrementScale
	return newValue
end

Slider.__index = function(object, indexed)
	local deprecated = {
		{".OnChange", ".Changed", rawget(object, "Changed")}
	}

	for _, tbl in ipairs(deprecated) do
		local deprecatedStr = string.sub(tbl[1], 2)

		if deprecatedStr == indexed then
			warn(string.format("%s is deprecated, please use %s instead", tbl[1], tbl[2]))
			return tbl[3]	
		end
	end

	return Slider[indexed]
end

export type configDictionary = {
	SliderData: {Start: number, End: number, Increment: number, DefaultValue: number | nil},
	MoveType: "Tween" | "Instant" | nil,
	MoveInfo: TweenInfo | nil,
	Axis: string | nil,
	Padding: number | nil,
	AllowBackgroundClick: boolean
}

function Slider.new(holder: GuiBase2d, config: configDictionary)
	assert(pcall(function()
		return holder.AbsoluteSize, holder.AbsolutePosition
	end), "Holder argument does not have an AbsoluteSize/AbsolutePosition")

	local duplicate = false
	for _, slider in ipairs(Slider.Sliders) do
		if slider._holder == holder then
			duplicate = true
			break
		end
	end

	assert(not duplicate, "Cannot set two sliders with same frame!")
	assert(config.SliderData.Increment ~= nil, "Failed to find Increment in SliderData table")
	assert(config.SliderData.Start ~= nil, "Failed to find Start in SliderData table")
	assert(config.SliderData.End ~= nil, "Failed to find End in SliderData table")
	assert(config.SliderData.Increment > 0, "SliderData.Increment must be greater than 0")
	assert(config.SliderData.End > config.SliderData.Start, string.format("Slider end value must be greater than its start value! (%.1f <= %.1f)", config.SliderData.End, config.SliderData.Start))

	local self = setmetatable({}, Slider)
	self._holder = holder
	self._data = {
		-- Buttons
		Button = nil,
		HolderButton = nil,

		-- Clicking
		_clickOverride = false,

		_mainConnection = nil,
		_clickConnections = {},
		_otherConnections = {},

		_inputPos = nil,

		-- Internal
		_percent = 0,
		_value = 0,
		_scaleIncrement = 0,
		_currentTween = nil,
		_allowBackgroundClick = if config.AllowBackgroundClick == false then false else true
	}

	self._config = config
	self._config.Axis = string.upper(config.Axis or "X")
	self._config.Padding = config.Padding or 5
	self._config.MoveInfo = config.MoveInfo or TweenInfo.new(0.2)
	self._config.MoveType = config.MoveType or "Tween"
	self.IsHeld = false

	local sliderBtn = holder:FindFirstChild("Slider")
	assert(sliderBtn ~= nil, "Failed to find slider button.")
	assert(sliderBtn:IsA("GuiButton"), "Slider is not a GuiButton")

	self._data.Button = sliderBtn

	-- Holder button --
	if self._data._allowBackgroundClick then
		local holderClickButton = Instance.new("TextButton")
		holderClickButton.BackgroundTransparency = 1
		holderClickButton.Text = ""
		holderClickButton.AnchorPoint = Vector2.new(0.5, 0.5)
		holderClickButton.Name = "HolderClickButton"
		holderClickButton.Size = UDim2.fromScale(1, 3.6)
		holderClickButton.Position = UDim2.fromScale(0.5,0.5)
		holderClickButton.ZIndex = -1
		holderClickButton.Parent = self._holder
		self._data.HolderButton = holderClickButton
	end

	-- Finalise --

	self._data._percent = 0
	if config.SliderData.DefaultValue then
		config.SliderData.DefaultValue = math.clamp(config.SliderData.DefaultValue, config.SliderData.Start, config.SliderData.End)
		self._data._percent = SliderFuncs.getAlphaBetween(config.SliderData.Start, config.SliderData.End, config.SliderData.DefaultValue) 
	end

	self._data._percent = math.clamp(self._data._percent, 0, 1)

	self._data._value = SliderFuncs.getNewValue(self)
	self._data._increment = config.SliderData.Increment
	self._data._scaleIncrement = SliderFuncs.getScaleIncrement(self)

	self.Changed = Signal.new()
	self.Dragged = Signal.new()
	self.Released = Signal.new()

	self._data._percent = SliderFuncs.snapToScale(self._data._percent, self._data._scaleIncrement)
	self:Move()

	table.insert(self._data._otherConnections, sliderBtn:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		self:Move("Instant")
	end))

	table.insert(Slider.Sliders, self)

	return self
end

function Slider:Track()
	for _, connection in ipairs(self._data._clickConnections) do
		connection:Disconnect()
	end

	table.insert(self._data._clickConnections, self._data.Button.MouseButton1Down:Connect(function()
		self.IsHeld = true
	end))

	table.insert(self._data._clickConnections, self._data.Button.MouseButton1Up:Connect(function()
		if self.IsHeld then
			self.Released:Fire(self._data._value)
		end
		self.IsHeld = false
	end))

	if self._data._allowBackgroundClick then
		table.insert(self._data._clickConnections, self._data.HolderButton.Activated:Connect(function(inputObject: InputObject)
			if inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch then
				self._data._inputPos = inputObject.Position
				self._data._clickOverride = true
				self:Update()
				self.Released:Fire()
				self._data._clickOverride = false
			end
		end))
	end

	if self.Changed then
		self.Changed:Fire(self._data._value)
	end

	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end

	self._data._mainConnection = UserInputService.InputChanged:Connect(function(inputObject, gameProcessed)
		if inputObject.UserInputType == Enum.UserInputType.MouseMovement or inputObject.UserInputType == Enum.UserInputType.Touch then
			self._data._inputPos = inputObject.Position
			self:Update()
		end
	end)
end

function Slider:Update()
	if (self.IsHeld or self._data._clickOverride) and self._data._inputPos then
		local sliderSize = self._holder.AbsoluteSize[self._config.Axis]
		local sliderPos = self._holder.AbsolutePosition[self._config.Axis]

		local mousePos = self._data._inputPos[self._config.Axis]

		if mousePos then
			local relativePos = (mousePos - sliderPos)
			local newPos = SliderFuncs.snapToScale(relativePos / sliderSize, self._data._scaleIncrement)

			local percent = math.clamp(newPos, 0, 1)
			self._data._percent = percent
			self.Dragged:Fire(self._data._value)
			self:Move()
		end
	end
end

function Slider:Untrack()
	for _, connection in ipairs(self._data._clickConnections) do
		connection:Disconnect()
	end
	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end
	self.IsHeld = false
end

function Slider:Reset()
	for _, connection in ipairs(self._data._clickConnections) do
		connection:Disconnect()
	end
	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end

	self.IsHeld = false

	self._data._percent = 0
	if self._config.SliderData.DefaultValue then 
		self._data._percent = SliderFuncs.getAlphaBetween(self._config.SliderData.Start, self._config.SliderData.End, self._config.SliderData.DefaultValue)
	end
	self._data._percent = math.clamp(self._data._percent, 0, 1)
	self:Move()
end

function Slider:OverrideValue(newValue: number)
	self.IsHeld = false
	self._data._percent = SliderFuncs.getAlphaBetween(self._config.SliderData.Start, self._config.SliderData.End, newValue)
	self._data._percent = math.clamp(self._data._percent, 0, 1)
	self._data._percent = SliderFuncs.snapToScale(self._data._percent, self._data._scaleIncrement)
	self:Move()
end

function Slider:Move(override: string)
	self._data._value = SliderFuncs.getNewValue(self)

	local moveType = if override ~= nil then override else self._config.MoveType
	if moveType == "Tween" or moveType == nil then
		if self._data._currentTween then
			self._data._currentTween:Cancel()
		end
		self._data._currentTween = TweenService:Create(self._data.Button, self._config.MoveInfo, {
			Position = SliderFuncs.getNewPosition(self)
		})
		self._data._currentTween:Play()
	elseif moveType == "Instant" then
		self._data.Button.Position = SliderFuncs.getNewPosition(self)
	end
	self.Changed:Fire(self._data._value)
end

function Slider:OverrideIncrement(newIncrement: number)
	self._config.SliderData.Increment = newIncrement
	self._data._increment = newIncrement
	self._data._scaleIncrement = SliderFuncs.getScaleIncrement(self)
	self._data._percent = math.clamp(self._data._percent, 0, 1)
	self._data._percent = SliderFuncs.snapToScale(self._data._percent, self._data._scaleIncrement)
	self:Move()
end

function Slider:GetValue()
	return self._data._value
end

function Slider:GetIncrement()
	return self._data._increment
end

function Slider:Destroy()
	for _, connection in ipairs(self._data._clickConnections) do
		connection:Disconnect()
	end
	for _, connection in ipairs(self._data._otherConnections) do
		connection:Disconnect()
	end

	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end

	if self._data.HolderButton then
		self._data.HolderButton:Destroy()
		self._data.HolderButton = nil
	end

	self.Changed:Destroy()
	self.Dragged:Destroy()
	self.Released:Destroy()

	for index = 1, #Slider.Sliders do
		if Slider.Sliders[index] == self then
			table.remove(Slider.Sliders, index)
		end
	end

	setmetatable(self, nil)
	self = nil
end

UserInputService.InputEnded:Connect(function(inputObject: InputObject, internallyProcessed: boolean)
	if inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch then
		for _, slider in ipairs(Slider.Sliders) do
			if slider.IsHeld then
				slider.Released:Fire(slider._data._value)
			end
			slider.IsHeld = false
		end
	end 
end);

local Assets = Dependencies:WaitForChild("Assets");

local MainUI = Dependencies.Parent.MainUI;
local Contents = MainUI:WaitForChild("Content");

local SideBar = Contents:WaitForChild("SideBar");
local MainContents = Contents:WaitForChild("MainContents");

local Management = {};
Management.__index = Management;
Management.Methods = {};
Management.Enums = {
	["UnitType"] = {
		["Switch"] = {
			["Value"] = 0;
			["Name"] = "Switch";
		};
		["Dropdown"] = {
			["Value"] = 1;
			["Name"] = "Dropdown";
		};
		["Slider"] = {
			["Value"] = 2;
			["Name"] = "Slider";
		};
		["String"] = {
			["Value"] = 3;
			["Name"] = "String";
		};
	};
};
local Enums = Management.Enums;
local Methods = Management.Methods;
Methods.__index = Methods;

local MainHub = {
	Contents = {

	}
}

local Units = {

}

local Tweenings = {
	Fading = nil;
}

local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()

local Hovered = false
local Holding = false
local MoveCon = nil

local InitialX, InitialY, UIInitialPos

local ViewPortSize = workspace.Camera.ViewportSize

local MoveTween = nil

local Syntax = 0;

local LoadedIn = Signal.new()

--[[ Creator ]] do
	function Management.initialize()
		MainUI.Parent.Dependencies.Audios.Opening:Play();
		
		local function Drag()
			if Holding == false then MoveCon:Disconnect(); return end
			local distanceMovedX = InitialX - Mouse.X
			local distanceMovedY = InitialY - Mouse.Y

			MoveTween = TweenService:Create(MainUI, TweenInfo.new(0.3, Enum.EasingStyle.Cubic, Enum.EasingDirection.Out), {Position = UIInitialPos - UDim2.new(0, distanceMovedX, 0, distanceMovedY)}):Play()
		end

		MainUI.Topbar.DragActivator.MouseEnter:Connect(function()
			Hovered = true
		end)

		MainUI.Topbar.DragActivator.MouseLeave:Connect(function()
			Hovered = false
		end)

		UserInputService.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				Holding = Hovered
				if Holding then
					InitialX, InitialY = Mouse.X, Mouse.Y
					UIInitialPos = MainUI.Position

					MoveCon = RunService.PreRender:Connect(Drag)
				end
			end
		end)

		UserInputService.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				Holding = false
			end
		end)

		TweenService:Create(MainUI.Sizer, TweenInfo.new(1.7, Enum.EasingStyle.Quint), {AspectRatio = 1.5}):Play();
		task.delay(0.6, function()
			TweenService:Create(MainUI.Loading.LoadingContent.Bar, TweenInfo.new(1, Enum.EasingStyle.Quint), {Size = UDim2.fromScale(1,0.05)}):Play();

			task.delay(0.5, function()
				TweenService:Create(MainUI.Loading.LoadingContent.Bar.MainBar.Slider, TweenInfo.new(0.5, Enum.EasingStyle.Linear), {Offset = Vector2.new(-0.32,0)}):Play();
				task.wait(math.random(2, 4))
				TweenService:Create(MainUI.Loading.LoadingContent.Bar.MainBar.Slider, TweenInfo.new(0.5, Enum.EasingStyle.Linear), {Offset = Vector2.new(0.1,0)}):Play();
				task.wait(math.random(1, 3))
				TweenService:Create(MainUI.Loading.LoadingContent.Bar.MainBar.Slider, TweenInfo.new(1.3, Enum.EasingStyle.Quint), {Offset = Vector2.new(0.6,0)}):Play();
				
				task.delay(1.5, function()
					MainUI.Parent.Dependencies.Audios.Loaded:Play();
					LoadedIn:Fire()
					task.wait(0.2)
					TweenService:Create(MainUI.Loading, TweenInfo.new(1, Enum.EasingStyle.Quint), {GroupTransparency = 1}):Play();
				end)	
			end)
		end)		
	end

	function Management.newContent(ContentName : string)
		local self = setmetatable({
			ContentName = ContentName;
		}, Methods);

		local newSideButton = Assets:WaitForChild("SideButtonTemplate"):Clone();
		newSideButton.Parent = SideBar;
		newSideButton.Name = ContentName.."SideButton"
		newSideButton.Visible = true

		local newSelectedStroke = Assets:WaitForChild("SelectedSideButtonStroke"):Clone();
		newSelectedStroke.Parent = newSideButton;

		newSideButton.Name = ContentName;

		local newWindow = Assets:WaitForChild("WindowTemplate"):Clone();
		newWindow.Parent = MainContents;
		newWindow.Name = ContentName.."Window"
		newWindow.Visible = true

		self.SideButton = newSideButton;
		self.SelectionStroke = newSelectedStroke;
		self.Window = newWindow.Window;

		MainHub.Contents[ContentName] = {
			SideButton = newSideButton;
			Window = newWindow;
		};

		return self;
	end;
end;

--[[ Methods ]] do

	-- Side Button
	function Methods.setSideButtonTitle(self, SideTitle : string)
		self.SideButton.ButtonTitle.Text = SideTitle;
		return self;
	end;

	function Methods.setSideButtonLogo(self, Logo : string)
		self.SideButton.Icon.ImageLabel.Image = Logo;
		return self;
	end;

	-- Window
	function Methods.openWindow(self)
		if self.Window.Parent.Visible == false then
			if Tweenings.Fading ~= nil then
				Tweenings.Fading:Pause();
			end;
			Tweenings.Fading = TweenService:Create(MainUI.Fader, TweenInfo.new(0.5, Enum.EasingStyle.Linear), {GroupTransparency = 0}):Play();
			task.delay(0.5, function()
				for i, v in pairs(MainHub.Contents) do
					if v.Window ~= self.Window.Parent then
						v.Window.Visible = false
					end
				end
				Tweenings.Fading = TweenService:Create(MainUI.Fader, TweenInfo.new(0.5, Enum.EasingStyle.Linear), {GroupTransparency = 1}):Play();
				self.Window.Parent.Visible = true;
			end)
		end
		return self;
	end;

	function Methods.addSpacial(self)
		Syntax += 1;
		local newSpacial = Assets:WaitForChild("Spacial"):Clone()
		newSpacial.Parent = self.Window;
		newSpacial.Visible = true;
		return self;
	end
	
	function Methods.addSpacialLine(self)
		Syntax += 1;
		local newSpacial = Assets:WaitForChild("SpacialLine"):Clone()
		newSpacial.Parent = self.Window;
		newSpacial.Visible = true;
		return self;
	end

	function Methods.addWindowTitle(self, Title : string)
		Syntax += 1;
		local newTitle = Assets:WaitForChild("WindowTitle"):Clone()
		newTitle.Parent = self.Window;
		newTitle.Text = Title;
		newTitle.LayoutOrder = Syntax;
		newTitle.Visible = true;
		return self;
	end

	function Methods.addWindowSubtitle(self, Subtitle : string)
		Syntax += 1;
		local newTitle = Assets:WaitForChild("Subtitle"):Clone()
		newTitle.Parent = self.Window;
		newTitle.Text = Subtitle;
		newTitle.LayoutOrder = Syntax;
		newTitle.Visible = true;
		return self;
	end

	function Methods.addUnit(self, UnitName, UnitType, Data : {any})
		Syntax += 1
		if UnitType == Enums.UnitType.Switch then
			local newSwitchAction = Assets:WaitForChild("UnitSwitch"):Clone();
			newSwitchAction.Parent = self.Window;
			newSwitchAction.Visible = true;
			newSwitchAction.LayoutOrder = Syntax;
			newSwitchAction.UnitTitle.Text = UnitName

			newSwitchAction:WaitForChild("Action"):WaitForChild("MainSwitch"):WaitForChild("SwitchButtonView")

			Units[UnitName] = {
				Data = Data;
				Connections = {};
				TurnedOn = Data.defaultValue;
				Debounce = false;
				OnValueChanged = Signal.new();
			};

			local MainUnit = Units[UnitName]

			local function Run()
				if MainUnit.TurnedOn == false then
					MainUnit.TurnedOn = true;

					Data.onActivated(MainUnit, true);
					TweenService:Create(newSwitchAction.Action.MainSwitch.SwitchButtonView, TweenInfo.new(0.2, Enum.EasingStyle.Back), {BackgroundColor3 = Color3.fromRGB(50, 64, 126), Position = UDim2.fromScale(0.2,0.5)}):Play()
					TweenService:Create(newSwitchAction.Action.MainSwitch.SwitchButtonView.Up, TweenInfo.new(0.2, Enum.EasingStyle.Back), {BackgroundColor3 = Color3.fromRGB(101, 129, 255)}):Play()
				else
					MainUnit.TurnedOn = false;

					Data.onDeactivated(MainUnit, false);
					TweenService:Create(newSwitchAction.Action.MainSwitch.SwitchButtonView, TweenInfo.new(0.2, Enum.EasingStyle.Back), {BackgroundColor3 = Color3.fromRGB(62, 111, 58), Position = UDim2.fromScale(0.8,0.5)}):Play()
					TweenService:Create(newSwitchAction.Action.MainSwitch.SwitchButtonView.Up, TweenInfo.new(0.2, Enum.EasingStyle.Back), {BackgroundColor3 = Color3.fromRGB(142, 255, 134)}):Play()
				end;
			end

			Run()

			MainUnit.Connections["SwitchActivated"] = newSwitchAction.Action.Activator.Activated:Connect(function()
				if MainUnit.Debounce == false then
					Run()
					MainUnit.OnValueChanged:Fire(MainUnit.TurnedOn)
					MainUnit.Debounce = true;
					task.wait(Data.cooldown)
					MainUnit.Debounce = false;
				end
			end);

			Data.Initialize(MainUnit)
		elseif UnitType == Enums.UnitType.String then
			local newStringAction = Assets:WaitForChild("UnitString"):Clone();
			newStringAction.Parent = self.Window;
			newStringAction.Visible = true;
			newStringAction.LayoutOrder = Syntax;
			newStringAction.UnitTitle.Text = UnitName

			newStringAction:WaitForChild("Action"):WaitForChild("MainString"):WaitForChild("TextBox")

			Units[UnitName] = {
				Data = Data;
				Connections = {};
				InitialValue = Data.defaultValue;
				Debounce = false;
				OnValueChanged = Signal.new();
			};

			local MainUnit = Units[UnitName]

			local function Run()
				newStringAction.Action.MainString.TextBox.Text = MainUnit.InitialValue;
				Data.onEntered(MainUnit, MainUnit.InitialValue);
			end

			Run()

			MainUnit.Connections["EnteredNumber"] = newStringAction.Action.MainString.TextBox.FocusLost:Connect(function()
				if MainUnit.Debounce == false then
					MainUnit.InitialValue = newStringAction.Action.MainString.TextBox.Text
					Run()
					MainUnit.OnValueChanged:Fire(MainUnit.InitialValue)
					MainUnit.Debounce = true
					task.wait(Data.cooldown);
					MainUnit.Debounce = false;
				end;
			end);

			Data.Initialize(MainUnit)
		elseif UnitType == Enums.UnitType.Dropdown then
			local newDropdownAction = Assets:WaitForChild("UnitDropdown"):Clone();
			newDropdownAction.Parent = self.Window;
			newDropdownAction.Visible = true;
			newDropdownAction.LayoutOrder = Syntax;
			newDropdownAction.UnitTitle.Text = UnitName

			newDropdownAction:WaitForChild("Action"):WaitForChild("DropdownInt"):WaitForChild("Container"):WaitForChild("DropdownMenu")

			local CreatedEnums = {};
			Data.createEnums(function(EnumItems : {})
				CreatedEnums = EnumItems;
			end);

			Units[UnitName] = {
				Data = Data;
				Connections = {};
				Selected = nil;
				DropdownOpen = false;
				Debounce = false;
				OnValueChanged = Signal.new();
			};

			local MainUnit = Units[UnitName];

			for i, v in pairs(CreatedEnums) do
				local newDropEnum = Assets:WaitForChild("DropdownOption"):Clone();
				newDropEnum.DropdownTitle.Text = v.Name;
				newDropEnum.Parent = newDropdownAction.Action.DropdownInt.Container.DropdownMenu;
				newDropEnum.Visible = true;

				MainUnit.Connections["DropdownSelect"..v.Name] = newDropEnum.Activator.Activated:Connect(function()
					if MainUnit.Selected ~= nil then
						if MainUnit.Selected.Value ~= v.Value then
							MainUnit.OnValueChanged:Fire(CreatedEnums[v.Name])
						end
					else
						MainUnit.OnValueChanged:Fire(CreatedEnums[v.Name])
					end
					MainUnit.Selected = CreatedEnums[v.Name];

					newDropdownAction.Action.MainDropdown.SelectedPreview.Text = v.Name;
				end);
			end;

			MainUnit.Connections["OpenedDropdown"] = newDropdownAction.Action.Activator.Activated:Connect(function()
				if MainUnit.Debounce == false then
					if MainUnit.DropdownOpen == false then
						MainUnit.DropdownOpen = true
						newDropdownAction.Action.DropdownInt.Container.Visible = true;
						TweenService:Create(newDropdownAction.Action.DropdownInt.Container.Slider, TweenInfo.new(.2, Enum.EasingStyle.Quint), {Offset = Vector2.new(0,1)}):Play();
					else
						newDropdownAction.Action.DropdownInt.Container.Visible = false;
						TweenService:Create(newDropdownAction.Action.DropdownInt.Container.Slider, TweenInfo.new(.2, Enum.EasingStyle.Quint), {Offset = Vector2.new(0,-1)}):Play();
						task.delay(.2, function()
							MainUnit.DropdownOpen = false;
						end);
					end;
					MainUnit.Debounce = true;
					task.wait(0.2 + Data.cooldown);
					MainUnit.Debounce = false;
				end;
			end);

			Data.Initialize(MainUnit)
		elseif UnitType == Enums.UnitType.Slider then
			local newSliderAction = Assets:WaitForChild("UnitSliderValue"):Clone();
			newSliderAction.Parent = self.Window;
			newSliderAction.Visible = true;
			newSliderAction.LayoutOrder = Syntax;
			newSliderAction.UnitTitle.Text = UnitName;

			local NewSliderSystem = Slider.new(newSliderAction.Action.SliderBase, {
				SliderData = {
					Start = Data.Min, End = Data.Max, Increment = Data.Increment
				};
				MoveInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quint);
			});

			Units[UnitName] = {
				Data = Data;
				Connections = {};
				CurrentValue = Data.defaultValue;
				Debounce = false;
				OnValueChanged = Signal.new();
			};

			local MainUnit = Units[UnitName]

			newSliderAction.Action.MainString.TextBox.Text = MainUnit.CurrentValue;

			NewSliderSystem:Track()
			MainUnit.Connections["SliderValueChange"] = NewSliderSystem.Changed:Connect(function(Value)
				newSliderAction.Action.MainString.TextBox.Text = Value;
			end)

			MainUnit.Connections["SliderReleased"] = NewSliderSystem.Released:Connect(function()
				MainUnit.OnValueChanged:Fire(NewSliderSystem:GetValue());
			end);

			MainUnit.Connections["TextboxChange"] = newSliderAction.Action.MainString.TextBox.FocusLost:Connect(function(Entered)
				if MainUnit.Debounce == false then
					if Entered then
						local success, number = pcall(tonumber, newSliderAction.Action.MainString.TextBox.Text)

						if success then
							NewSliderSystem:OverrideValue(number)
							MainUnit.OnValueChanged:Fire(number);
						end
					end
				end
			end)

			Data.Initialize(MainUnit)
		end;

		return self;
	end;
end;

local Storage = Instance.new("Folder", Dependencies)
Storage.Name = "Storage"

local function InitializeStringRandomizer(length)
	local characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789~!@#$%^&*/`()|-=+";
	local RanStr = "";
	for i = 1, length do
		local randomIndex = math.random(1, #characters);
		RanStr = string.format("%s%s", RanStr, string.sub(characters, randomIndex, randomIndex));
	end;
	return RanStr;
end

local GlobalData = {
	ESPs = {};
	PlayerRoles = nil;
	Connections = {}
}

Management.initialize()

LoadedIn:Connect(function()
	LoadedIn:Connect(function()
	Management.newContent("Game")
		:setSideButtonTitle("Game")
		:addWindowTitle("Player")
		:addSpacialLine()
		:addWindowSubtitle("ESP")
		:addUnit("Players ESP", Enums.UnitType.Switch, {
			onActivated = function(MainUnit, Value)			
				local function InitializeESP()
					for i, esp in pairs(GlobalData.ESPs) do
						esp:Destroy();
					end;

					for i, Player in pairs(game:GetService("Players"):GetPlayers()) do
						local newHighlight = Instance.new("Highlight", Storage)
						newHighlight.Name = Player.Name
						newHighlight.FillColor = Color3.fromRGB(157, 255, 111)
						newHighlight.FillTransparency = 0.5
						newHighlight.OutlineColor = Color3.fromRGB(157, 255, 111)
						newHighlight.OutlineTransparency = 0.6

						table.insert(GlobalData.ESPs, newHighlight);
					end
				end

				local function findSheriff()
					for i, player in pairs(game:GetService("Players"):GetPlayers()) do
						if player.Backpack:FindFirstChild("Gun") then
							return player
						end
					end

					for i, player in pairs(game:GetService("Players"):GetPlayers()) do
						if player.Character:FindFirstChild("Gun") then
							return player
						end
					end

					if GlobalData.PlayerRoles then
						for player, data in GlobalData.PlayerRoles do
							if data.Role == "Sheriff" then
								if game:GetService("Players"):FindFirstChild(player) then
									return game:GetService("Players"):FindFirstChild(player)
								end
							end
						end
					end
				end

				local function findMurderer()
					for i, player in pairs(game:GetService("Players"):GetPlayers()) do
						if player.Backpack:FindFirstChild("Knife") then
							return player
						end
					end

					for i, player in pairs(game:GetService("Players"):GetPlayers()) do
						if player.Character:FindFirstChild("Knife") then
							return player
						end
					end

					if GlobalData.PlayerRoles then
						for player, data in GlobalData.PlayerRoles do
							if data.Role == "Murderer" then
								if game:GetService("Players"):FindFirstChild(player) then
									return game:GetService("Players"):FindFirstChild(player)
								end
							end
						end
					end
				end

				local function loadEsp()
					InitializeESP()
					for i, player in pairs(game:GetService("Players"):GetPlayers()) do
						if player == findSheriff() then
							local esp = Storage:FindFirstChild(player.Name)
							esp.Adornee = player.Character
							esp.FillColor = Color3.fromRGB(105, 125, 255)
							esp.OutlineColor = Color3.fromRGB(105, 125, 255)
						elseif player == findMurderer() then
							local esp = Storage:FindFirstChild(player.Name)
							esp.Adornee = player.Character
							esp.FillColor = Color3.fromRGB(255, 97, 97)
							esp.OutlineColor = Color3.fromRGB(255, 97, 97)
						else
							local esp = Storage:FindFirstChild(player.Name)
							esp.FillColor = Color3.fromRGB(157, 255, 111)
							esp.OutlineColor = Color3.fromRGB(157, 255, 111)
						end
					end
				end

				GlobalData.Connections["HookRoles"] = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Gameplay"):WaitForChild("PlayerDataChanged", 5).OnClientEvent:Connect(function(RoleData)
					GlobalData.PlayerRoles = RoleData
					loadEsp()				
				end)

				loadEsp()
				
				GlobalData.Connections["PlayerAdd"] = game:GetService("Players").PlayerAdded:Connect(function()
					loadEsp()
				end)
				
				GlobalData.Connections["PlayerRemove"] = game:GetService("Players").PlayerRemoving:Connect(function()
					loadEsp()
				end)
			end,
			onDeactivated = function(MainUnit, Value)
				GlobalData.Connections["HookRoles"]:Disconnect();
				GlobalData.Connections["PlayerAdd"]:Disconnect();
				GlobalData.Connections["PlayerRemove"]:Disconnect();

				for i, esp in pairs(GlobalData.ESPs) do
					esp:Destroy();
				end;
			end,
			otherData = {
				
			},
			defaultValue = false,
			cooldown = 0.2,
		})
		:addUnit("Walkspeed", Enums.UnitType.Slider, {
			Initialize = function(Unit)
				Unit.OnValueChanged:Connect(function()
					pcall(function()
						game:GetService("Players").LocalPlayer.Character:FindFirstChild("Humanoid").WalkSpeed.Value = Unit.CurrentValue
					end)
				end)
			end,
			defaultValue = 16,
			Min = 16,
			Max = 30,
			Increment = 1,
		})

	Management.setOpenedWindow("Home")
end)

Dependencies.Parent.Name = InitializeStringRandomizer(7)
